# Stubs for twisted.internet.defer (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from twisted.python import lockfile
from typing import Any, Callable, Generic, Optional, TypeVar

class AlreadyCalledError(Exception): ...
class CancelledError(Exception): ...
class TimeoutError(Exception): ...

def succeed(result: Any): ...
def fail(result: Optional[Any] = ...): ...
def maybeDeferred(f: Any, *args: Any, **kw: Any): ...

T = TypeVar('T')
class Deferred(Generic[T]):
    called: bool = ...
    paused: bool = ...
    debug: bool = ...
    callbacks: Any = ...
    def __init__(self, canceller: Optional[Any] = ...) -> None: ...
    def addCallbacks(self,
                     callback: Callable[[T], Any],
                     errback: Optional[Any] = ...,
                     callbackArgs: Optional[Any] = ...,
                     callbackKeywords: Optional[Any] = ...,
                     errbackArgs: Optional[Any] = ...,
                     errbackKeywords: Optional[Any] = ...): ...
    def addCallback(self, callback: Callable[[T], Any], *args: Any, **kw: Any): ...
    def addErrback(self, errback: Any, *args: Any, **kw: Any): ...
    def addBoth(self, callback: Callable[[T], Any], *args: Any, **kw: Any): ...
    def addTimeout(self, timeout: Any, clock: Any, onTimeoutCancel: Optional[Any] = ...): ...
    def chainDeferred(self, d: Any): ...
    def callback(self, result: T) -> None: ...
    def errback(self, fail: Optional[Any] = ...) -> None: ...
    def pause(self) -> None: ...
    def unpause(self) -> None: ...
    def cancel(self) -> None: ...
    def __iter__(self): ...
    def send(self, value: Optional[Any] = ...): ...
    __await__: Any = ...
    __next__: Any = ...
    def asFuture(self, loop: Any): ...
    @classmethod
    def fromFuture(cls, future: Any): ...

def ensureDeferred(coro: Any): ...

class DebugInfo:
    failResult: Any = ...
    def __del__(self) -> None: ...

class FirstError(Exception):
    subFailure: Any = ...
    index: Any = ...
    def __init__(self, failure: Any, index: Any) -> None: ...
    def __cmp__(self, other: Any): ...

class DeferredList(Deferred):
    fireOnOneCallback: bool = ...
    fireOnOneErrback: bool = ...
    resultList: Any = ...
    consumeErrors: Any = ...
    finishedCount: int = ...
    def __init__(self, deferredList: Any, fireOnOneCallback: bool = ..., fireOnOneErrback: bool = ..., consumeErrors: bool = ...) -> None: ...
    def cancel(self) -> None: ...

def gatherResults(deferredList: Any, consumeErrors: bool = ...): ...

SUCCESS: bool
FAILURE: bool

class waitForDeferred:
    d: Any = ...
    def __init__(self, d: Any) -> None: ...
    def getResult(self): ...

def deferredGenerator(f: Any): ...

class _DefGen_Return(BaseException):
    value: Any = ...
    def __init__(self, value: Any) -> None: ...

def returnValue(val: Any) -> None: ...

class _InternalInlineCallbacksCancelledError(Exception): ...

def inlineCallbacks(f: Any): ...

class _ConcurrencyPrimitive:
    waiting: Any = ...
    def __init__(self) -> None: ...
    def run(*args: Any, **kwargs: Any): ...

class DeferredLock(_ConcurrencyPrimitive):
    locked: bool = ...
    def acquire(self): ...
    def release(self) -> None: ...

class DeferredSemaphore(_ConcurrencyPrimitive):
    tokens: Any = ...
    limit: Any = ...
    def __init__(self, tokens: Any) -> None: ...
    def acquire(self): ...
    def release(self) -> None: ...

class QueueOverflow(Exception): ...
class QueueUnderflow(Exception): ...

class DeferredQueue:
    waiting: Any = ...
    pending: Any = ...
    size: Any = ...
    backlog: Any = ...
    def __init__(self, size: Optional[Any] = ..., backlog: Optional[Any] = ...) -> None: ...
    def put(self, obj: Any) -> None: ...
    def get(self): ...

class AlreadyTryingToLockError(Exception): ...

class DeferredFilesystemLock(lockfile.FilesystemLock):
    def __init__(self, name: Any, scheduler: Optional[Any] = ...) -> None: ...
    def deferUntilLocked(self, timeout: Optional[Any] = ...): ...

def setDebugging(yes: bool) -> None: ...
